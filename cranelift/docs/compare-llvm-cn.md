# Cranelift与LLVM的比较

LLVM是一个由C++库组成的编译器组件集合，可用于构建JIT（即时编译）和静态编译器，如Clang。Cranelift和LLVM在表面上相似，都使用主要的中间表示（IR）来抽象不同的目标指令集架构（ISA）。
两者都依赖于静态单赋值（SSA）形式，并且都能够跨编译。但它们在中间表示、程序结构、值类型和指令集方面有重要差异。

### 中间表示

LLVM使用多个中间表示来将程序转换为机器码：

- **LLVM IR**：主要中间表示，有文本、二进制和内存形式，用于表示ISA无关的语言和中级优化。
- **SelectionDAG**：指令选择过程中使用的图表示，用于类型和操作的合法化。
- **MachineInstr**：ISA特定的指令线性表示，最初是SSA形式，后来用于调度和寄存器分配。

Cranelift使用单一中间表示，通过指令选择后每条指令都带有ISA特定编码。这意味着Cranelift的设计更倾向于快速编译，牺牲了中级优化的空间。

### 程序结构

LLVM IR中的最大单元是模块，包含函数和全局变量。而Cranelift的IR中函数是自包含的，模块功能由可选的库层提供。Cranelift和LLVM都使用基本块的图作为函数的IR，但Cranelift使用基本块参数代替了LLVM的phi指令。

### 值类型

Cranelift的类型系统比LLVM更简化，整数类型限制为从`i8`到`i64`，浮点数为`f32`和`f64`。Cranelift没有指针类型或聚合类型，而LLVM有更丰富的类型系统。

### 指令集

LLVM有一个小的基本指令集和大量特定ISA的内联函数，而Cranelift具有更大的指令集，且无内联函数。Cranelift的每个指令集都会映射到特定的ISA指令，使其能够直接生成机器码。

### 总结

Cranelift比LLVM更加关注快速编译和代码生成的简化流程，尤其适合不需要中级优化的应用场景。LLVM则更适合需要高级优化和多样化功能的项目。两者各有优劣，适用于不同的需求。