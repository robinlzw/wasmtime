这篇文章是关于 Cranelift 中间表示（Intermediate Representation，IR）的参考文档。Cranelift IR 有两种主要形式：一种是代码生成库使用的*内存中数据结构*，另一种是用于测试用例和调试输出的*文本格式*。文本格式的 Cranelift IR 文件的扩展名是 `.clif`。

### 整体结构

Cranelift 独立编译函数。一个 `.clif` IR 文件可能包含多个函数，且 API 可以同时创建多个函数句柄，但函数之间不共享数据，也不直接引用彼此。

### 函数定义

函数定义的第一行提供了函数的*名称*和[函数签名]，它声明了参数和返回类型。接下来是[函数前序]，它声明了函数内部可引用的实体。例如，在上面的例子中，前序声明了一个显式的栈槽 `ss0`。

函数前序之后是[函数体]，由[基本块](BBs)组成，第一个是[入口块]。每个 BB 都以一个[终结器指令]结束，因此执行流程从来不会在没有显式分支的情况下流入下一个 BB。

### 静态单赋值形式（Static Single Assignment，SSA）

函数体中的指令使用 SSA 形式的*值*。这意味着每个值精确定义一次，且值的每次使用都必须在定义的支配下。

Cranelift 没有 phi 指令，而是使用[BB 参数]。一个 BB 可以定义为带有类型参数的列表。每当控制流转移到 BB 时，必须为参数提供实参。

### 值类型

所有 SSA 值都有一个类型，该类型决定了值的大小和形状（对于 SIMD 向量）。许多指令是多态的——它们可以操作不同类型的值。

#### 整数类型

整数类型有固定的大小，可以被解释为有符号数或无符号数。一些指令会将操作数解释为有符号数或无符号数，而其他指令则不关心。

- i8
- i16
- i32
- i64
- i128

在这些类型中，i32 和 i64 经过最严格的测试，因为它们被 Wasmtime 使用。i8、i16 和 i128 没有已知的错误，但它们的使用可能不受所有后端的所有指令支持（也就是说，它们可能会导致编译器在代码生成过程中崩溃，并报告一个指令不受支持的错误）。

#### 浮点类型

浮点类型遵循大多数硬件支持的 IEEE 754 语义，但当前不支持非默认舍入模式、未屏蔽异常和异常标志。

- f32
- f64

#### SIMD 向量类型

SIMD 向量类型表示来自标量类型（整数和浮点数）的值的向量。SIMD 类型的每个标量值称为*车道*。车道的数量必须是 2-256 范围内的 2 的幂。

#### 伪类型和类型类

这些不是具体类型，而是在本参考中用于引用真实类型的方便名称。

#### 立即数操作数类型

这些类型不是普通 SSA 类型系统的一部分。它们用于指示指令上不同类型的立即数操作数。

### 控制流

分支将控制权转移到新的 BB，并为目标 BB 的参数提供值（如果它有的话）。条件分支终结一个 BB，根据条件是否满足，将控制权转移到第一个或第二个 BB。

### 函数调用

函数调用需要一个目标函数和一个[函数签名]。目标函数可能在运行时动态确定，但签名必须在编译函数调用时已知。

### 内存

Cranelift 提供了完全通用的 `load` 和 `store` 指令来访问内存，以及[扩展加载和截断存储]。

### 显式栈槽

一组受限的内存操作访问当前函数的栈帧。栈帧被划分为在[函数前序]中分配的固定大小的栈槽。栈槽没有类型，它们简单地表示栈帧中的连续字节序列。

### 全局值

*全局值*是一个在编译时未知其值的对象。该值在运行时通过 `global_value` 计算，可能使用链接器通过重定位提供的信息。有多种类型的全局值，使用不同的方法来确定它们的值。

### 常量物质化

一些指令有变体，它们采用立即数操作数，但通常需要一个指令将常量加载到 SSA 值中：`iconst`、`f32const` 和 `f64const` 用于此目的。

### 位操作

位操作和操作对任何值类型都有效：整数和浮点数。当操作整数或浮点类型时，位操作是在值的二进制表示上进行的。

### 浮点操作

这些操作通常遵循 IEEE 754-2008 语义。

### 扩展加载和截断存储

大多数 ISA 提供了将小于寄存器宽度的整数值加载并扩展到寄存器宽度的指令。同样，只写入整数寄存器的低比特的存储指令也很常见。

### ISA 特定指令

目标 ISA 可以定义一些补充指令，这些指令对一般支持没有意义。

### 代码生成实现指令

前端不需要自己发出本节中的指令；Cranelift 会在需要时自动生成它们。

### 实施限制

Cranelift 的中间表示对函数大小和允许的实体数量施加了一些限制。如果超出这些限制，实现将会 panic。

### 术语表

- addressable
- accessible
- basic block
- entry block
- BB parameter
- BB argument
- function signature
- function preamble
- function body
- intermediate representation (IR)
- stack slot
- explicit stack slot
- spill stack slot
- terminator instruction
- trap

以下是对Cranelift IR中一些关键术语的翻译和解释：

- **可寻址（addressable）**
  在这种内存中，加载（loads）和存储（stores）操作有明确定义的行为。它们要么成功，要么根据内存是否[可访问（accessible）]，可能会触发一个[陷阱（trap）]。

- **可访问（accessible）**
  在这种[可寻址]内存中，加载和存储操作总是成功，不会触发[陷阱]，除非有其他特别说明（例如，使用了`aligned`标志）。堆、全局变量、表格和栈可能包含可访问的、仅仅可寻址的，以及完全不可寻址的区域。也可能存在额外的可寻址和/或可访问内存区域，但没有显式声明。

- **基本块（basic block）**
  一系列指令的最大序列，只能从头开始进入，并且除了最后一个指令外，不包含任何分支或终结器指令。

- **入口块（entry block）**
  在函数中首先执行的[基本块]。目前，Cranelift函数必须恰好有一个入口块，它必须是函数中的第一个块。入口块的参数类型必须与函数签名中的参数类型相匹配。

- **BB参数（BB parameter）**
  Basic Block的正式参数是一个SSA值，它支配了BB中的所有内容。对于BB声明的每个参数，分支到BB时必须传递相应的参数值。函数的入口BB有与函数参数相对应的参数。

- **BB参数（BB argument）**
  类似于函数参数，当分支到声明了形式参数的BB时，必须提供BB参数。当执行开始于BB的顶部时，形式参数具有分支中传递的参数值。

- **函数签名（function signature）**
  函数签名描述了如何调用一个函数。它包括调用约定、参数和返回值的数量（函数可以返回多个值）、每个参数的类型和标志、每个返回值的类型和标志。并非所有函数属性都是签名的一部分。例如，一个从不返回的函数可以被标记为`noreturn`，但这不是调用它时必须知道的信息，因此它只是一个属性，不是签名的一部分。

- **函数前序（function preamble）**
  函数体使用的实体声明列表。可以在前序中声明的一些实体包括：栈槽、直接调用的函数、间接函数调用的函数签名、不是签名一部分的函数标志和属性。

- **函数体（function body）**
  包含函数中所有可执行代码的基本块。函数体跟在函数前序之后。

- **中间表示（intermediate representation，IR）**
  用于向Cranelift描述函数的语言。这个参考文档描述了Cranelift IR的语法和语义。IR有两种形式：文本形式和内存中的数据结构。

- **栈槽（stack slot）**
  当前函数激活帧中的固定大小内存分配。包括[显式栈槽]和[溢出栈槽]。

- **显式栈槽（explicit stack slot）**
  当前函数激活帧中的固定大小内存分配。它们与[溢出栈槽]不同，因为它们可以由前端创建，并且它们的地址可以被获取。

- **溢出栈槽（spill stack slot）**
  当前函数激活帧中的固定大小内存分配。它们与[显式栈槽]不同，因为它们只在寄存器分配期间创建，它们的地址不能被获取。

- **终结器指令（terminator instruction）**
  一个控制流指令，它无条件地将执行流程导向其他地方。执行永远不会在终结器指令之后的指令继续。

  基本的终结器指令包括`br`、`return`和`trap`。条件分支和条件触发陷阱的指令不是终结器指令。

- **陷阱（trap）**
  终止当前线程的执行。陷阱之后的具体行为取决于底层操作系统。例如，一个常见的行为是发送一个信号，具体的信号取决于触发它的事件。

### 解释和总结

在Cranelift IR中，一些核心概念如可寻址内存、可访问内存、基本块、函数签名等对于理解代码的编译和执行至关重要。可寻址内存指的是加载和存储操作有明确定义行为的内存区域，而可访问内存则是可寻址内存中加载和存储操作总是成功的区域。基本块是一系列指令的序列，只能从头开始执行，且除了最后一个指令外不包含分支或终结器指令。函数签名定义了如何调用一个函数，包括调用约定、参数和返回值的数量及类型。函数前序是函数体使用的实体声明列表，而函数体则包含了函数中所有的可执行代码。

Cranelift IR通过这些概念提供了一种灵活且高效的方式来表示和操作代码，使得编译器能够针对不同的目标平台生成优化的机器代码。理解这些术语和概念有助于开发者更好地使用Cranelift，以及在编译器开发和代码优化领域进行更深入的探索。


---
这篇文章提供了 Cranelift IR 的全面介绍，包括其结构、类型系统、控制流、内存模型、全局值、常量物质化、位和浮点操作、ISA 特定指令以及代码生成实现指令。
