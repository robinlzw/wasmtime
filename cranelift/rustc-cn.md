# Cranelift 在 Rustc 中的应用
==================

Cranelift 的一个目标是作为一个适合于 Rust 调试模式编译的后端。这种模式不需要大量的中级优化，但它确实需要非常快的编译时间，这与我们预期的 Cranelift 初期的优势和劣势相当匹配。Cranelift 被设计为积极利用多核处理器，并且在内存使用上非常高效。

另一个目标是成为一个“相当不错”的后端。这里的想法是，通过在 Cranelift 中进行一些基本优化来实现 MIR 级别的内联，捕获一些容易实现的优化成果，然后利用这些优化加上良好的低级优化来产生代码，这些代码有可能相当快，并且编译时间非常快。显然，它在优化方面无法与基于 LLVM 的发布构建相竞争，但对于某些用户来说，完全未优化的代码太慢，无法进行测试，因此一个“相当不错”的模式可能已经足够好了。

为了实现这些目标，还有很多工作要做，如果我们实现了它们，我们将拥有一个完全用 Rust 编写的 Rust 编译器，并为重要的用例提供了更快的 Rust 编译时间。

有关需要完成的事项列表，请参阅 [标记为 "rustc" 的问题](https://github.com/bytecodealliance/wasmtime/labels/cranelift%3Agoal%3Arustc)。

说了这么多，还有一个潜在的目标，那就是构建一个完整的优化发布能力后端。我们现在还无法预测 Cranelift 会走多远，但我们确实有一些关于这样一个后端可能是什么样子的疯狂想法，包括：

- 利用 Rust 语言属性优化。使用 LLVM 时，Rust 能够使用注释来描述一些它的别名保证，但这些注释很尴尬且有限。一个能够直接表示 Rust 提供的核心别名关系的优化器，有潜力非常强大，无需复杂的别名分析逻辑。
  不安全代码块是一个有趣的挑战，但在许多简单的情况下，比如 `Vec`，可能可以恢复优化器需要知道的信息。
- 为超级优化设计。传统上，编译器开发团队花费了多年的手动努力来识别可以匹配和替换的代码模式。超级优化器已经为这项工作做出了一些贡献，但在将来，我们可能能够颠倒角色。超级优化器将完成大部分工作，人类将贡献超级优化器错过的专门优化。这有潜力使一个新的优化器从零开始，以更少的手动努力达到收益递减的领域。
- 构建一个没有快速调试构建编译约束的优化器 IR。Cranelift 的基础 IR 专注于代码生成，因此一个全功能的优化器将使用一个在其之上的 IR 层（可能使用 cranelift-entity 的灵活 `SecondaryMap`s），或者可能一个独立的 IR，可以转换为基础 IR。无论哪种方式，这种整体架构都将优化器排除在非优化构建路径之外，这使得该路径快速且简单，并为优化器提供了更多的灵活性。如果我们然后想基于一个强大的数据结构，如值状态依赖图（VSDG），我们可以在更少的妥协下这样做。

这些想法相互构建。例如，像 VSDG 这样的依赖图导向 IR 面临的挑战之一是获得足够好的内存依赖信息。但如果我们能够直接从 Rust 前端获得高质量的别名信息，我们应该处于非常好的状态。另一个例子是，对于超级优化器来说，控制流通常比表达式图更难理解。但是，像 VSDG 这样的图导向 IR 将控制流表示为控制依赖。很难说这种组合将有多么强大，直到我们尝试它，但如果没有什么，它应该非常方便地在一个包含数据和控制依赖的单一图上表达模式匹配。

### 解释和总结

Cranelift 旨在成为 Rust 编译器的后端，特别是在调试模式下，这种模式不需要复杂的优化，但需要快速的编译时间。Cranelift 的设计充分利用了多核处理能力和高效的内存使用，这与 Rust 调试模式的需求相匹配。

项目的目标之一是实现 MIR 级别的内联和基本优化，以创建一个“相当不错”的后端，即使它可能无法与 LLVM 的优化版本相媲美，但对于需要快速测试的用户来说，这可能已经足够。

为了实现这些目标，Cranelift 团队正在努力完成一系列任务，这些任务在项目的 GitHub 标签中有所列出。虽然目前无法访问这些标签的具体内容，但这些任务可能包括对 Cranelift 的进一步开发和优化。

Cranelift 的更远大目标是创建一个完整的优化发布能力后端，这可能包括利用 Rust 语言的属性进行优化、为超级优化设计，以及构建一个没有快速调试构建编译约束的优化器 IR。这些想法相互促进，例如，高质量的别名信息可以直接从 Rust 前端获得，这将有助于优化器更好地理解内存依赖。

总的来说，Cranelift 项目的目标是为 Rust 社区提供一个完全用 Rust 编写的编译器后端，这将有助于提高编译速度，并可能为 Rust 语言的未来发展提供新的可能性。
