# 安全

WebAssembly（以及 Wasmtime）的主要目标之一是在沙箱内以安全的方式执行不受信任的代码。WebAssembly 通过设计本质上是沙箱化的（必须导入所有功能等）。本文档旨在涵盖 Wasmtime 开发中的各种沙箱实现策略。这些也在一个[historical blog post]中有记录。

[historical blog post]: https://bytecodealliance.org/articles/security-and-correctness-in-wasmtime 

目前，Wasmtime 实现了 WebAssembly 规范所必需的功能，例如实例间的记忆隔离。此外，安全的 Rust API 旨在减少宿主中的意外错误。

不同的沙箱实现技术也将带来不同的性能和功能限制的权衡，Wasmtime 计划为用户提供他们想要做出的权衡选择。

## WebAssembly 核心

核心 WebAssembly 规范具有多个功能，可以创建一个独特的沙箱环境：

- 调用堆栈无法访问。与大多数本地执行环境不同，调用和溢出寄存器的返回地址不存储在应用程序可访问的内存中。它们存储在只有实现可以访问的内存中，这使得传统的针对返回地址的堆栈破坏攻击变得不可能。

- 指针，在具有它们的源语言中，被编译为线性内存中的偏移量，因此实现细节（如虚拟地址）对应用程序是隐藏的。并且所有在线性内存中的访问都被检查以确保它们保持在界限内。

- 所有控制转移——直接和间接分支以及直接和间接调用——都是已知的并且经过类型检查的目标，因此不可能意外地调用到函数的中间或分支到函数之外。

- 所有与外界的交互都是通过导入和导出完成的。没有对系统调用或其他形式的 I/O 的原始访问；WebAssembly 实例可以做的事情仅限于通过它明确链接的接口可用。

- 没有未定义的行为。即使 WebAssembly 规范允许多种可能的行为，它也不允许任意行为。

## 防御深度

虽然 WebAssembly 被设计为沙箱化，但不可避免地会出现错误或问题，因此 Wasmtime 还实现了一些不是执行 WebAssembly 所必需的缓解措施，但如果发现错误，可以帮助缓解问题：

* 默认情况下，线性内存前面有一个 2GB 的守护区域。WebAssembly 没有办法访问这段内存，但这可以防止 Cranelift 中的意外符号扩展错误，如果偏移量被意外地解释为有符号的 32 位偏移量而不是无符号偏移量，它可能会访问 WebAssembly 的可寻址内存之前的内存。

* Wasmtime 使用显式检查来确定是否应将 WebAssembly 函数视为栈溢出，但它仍然在所有本地线程栈上使用守护页面。这些守护页面从不打算被击中，如果被击中，将中止程序。在 WebAssembly 中击中守护页面表明宿主配置或 Cranelift 本身存在错误。

* Wasmtime 将在 WebAssembly 实例完成后尽可能地将其使用的内存清零。除非内存实际上被重用于其他地方的实例化，否则这不是必需的，但这可以防止在面对其他错误时实例之间的意外信息泄露。这适用于线性内存、表格以及用于存储实例信息的内存本身。

* 实现语言 Rust 的选择也是保护 Wasmtime 作者自己以及嵌入者自己的防御措施。Rust 有助于在编译时捕获编写 Wasmtime 本身时的错误。此外，Rust 还使 Wasmtime 开发者能够创建一个 API，意味着嵌入者不能出错。例如，可以保证使用其公共 API 时 Wasmtime 不会段错误，赋予嵌入者信心，即使嵌入有错误，WebAssembly 的所有安全保证仍然得到维护。

* Wasmtime 正在[实施控制流完整性机制][cfi-rfc]，以利用硬件状态进一步保证 WebAssembly 留在其沙箱内。如果 Cranelift 中存在错误，这可以帮助减轻控制流可能去往的地方的影响。

[cfi-rfc]: https://github.com/bytecodealliance/rfcs/blob/main/accepted/cfi-improvements-with-pauth-and-bti.md 

## 文件系统访问

Wasmtime 实现了 WASI API 用于文件系统访问，这些 API 遵循基于能力的安全性模型，确保应用程序只能访问它们被授权访问的文件和目录。WASI 的安全性模型今天可以保护用户，也有助于我们为未来的共享无链接和纳米进程做准备。

Wasmtime 开发者也密切参与了 WASI 标准过程、库和工具的开发。

## 终端输出

如果允许不受信任的代码打印显示在终端的文本，它可能会发出 ANSI 样式的转义序列和其他控制序列，这取决于用户使用的终端及其配置，可能会产生包括写入文件、执行命令、注入文本作为用户输入的文本，或读取以前命令的输出等副作用。ANSI 样式的转义序列也可能混淆或误导用户，使其他漏洞更容易被利用。

我们的首要任务是保护用户，因此 Wasmtime 现在在输出流连接到终端时过滤写入，以将转义序列转换为惰性替换序列。

一些应用程序需要 ANSI 样式的转义序列，例如基于终端的编辑器和使用颜色的程序，因此我们也正在为 WASI 小组开发一个关于安全和可移植的 ANSI 样式转义序列支持的提案，我们希望很快能更多地发布。

## Spectre

Wasmtime 目前实现了一些基本的 spectre 缓解措施：

* 访问函数表中的条目（例如 `call_indirect` 指令）时的界限检查得到了缓解。

* `br_table` 指令得到了缓解，以确保推测会去一个确定的位置。

* Wasmtime 对线性内存的默认配置意味着由于依赖于页面错误来检测越界访问，因此不会为内存访问存在界限检查。然而，当 Wasmtime 被配置为使用“动态”内存时，Cranelift 将插入所有内存访问执行的界限检查的 spectre 缓解措施。

缓解 Spectre 仍然是一个正在进行的研究主题，Wasmtime 将来也可能会增加更多的缓解措施。

---

总结：
Wasmtime 作为 WebAssembly 的运行时环境，非常重视安全性，它通过多种机制来确保在沙箱内安全地执行不受信任的代码。这些机制包括 WebAssembly 规范本身的沙箱特性，如隐藏调用堆栈、线性内存的界限检查、控制流的明确目标等。此外，Wasmtime 还实现了额外的防御措施，如内存守护区域、栈溢出检查、内存清零等，以应对可能的实现错误。Wasmtime 使用 Rust 语言实现，利用 Rust 的安全性来保护开发者和用户免受意外错误的影响。Wasmtime 还积极参与 WASI 标准的制定，实现了基于能力的文件系统访问，并计划支持安全的 ANSI 转义序列。对于 Spectre 攻击，Wasmtime 也实现了一些基本的缓解措施，并准备随着研究的进展继续增强这些措施。总的来说，Wasmtime 通过综合运用多种策略，努力为用户提供一个既安全又高效的 WebAssembly 运行环境。
