该文档讨论了WASI系统调用设计的几个关键问题，包括不采用传统的POSIX系统调用的原因。WASI与POSIX在安全性、能力模型和API设计上有本质区别。此外，文中探讨了阻塞和异步API的选择，强调了WASI的简化设计和避免复杂性，如未实现的`mmap`和UNIX域套接字等。最后，WASI倾向于将每个系统调用设计为执行单一操作，以便清晰地表达模块的能力。

以下是文章的主要内容总结：
---
### 为什么不采用传统的类似POSIX的系统调用？
- WebAssembly在一些基本方面不适合ELF模型，例如代码不在地址空间内，调用者需要知道被调用者确切的签名等。
- WebAssembly的一个独特属性是能够在不依赖操作系统进程边界的情况下运行沙盒化实例。如果要求wasm实例与重量级的操作系统进程一一对应，将失去这一关键优势。
- WebAssembly采用了面向能力的安全性方法，与POSIX风格的平台不同。Wasm核心无法直接与外界通信，只能通过与导入/导出的交互来实现。

### 为什么不是非阻塞的？
- 目前使用阻塞API是因为这是让wasm运行时和工具链达到可用状态的最简单方式。但非阻塞API可能有各种优势，这是一个值得讨论的开放性问题。

### 为什么不采用异步？
- 有关于如何将当前API扩展为异步的想法。例如，可以区分WebAssembly程序中的*命令*和*反应器*。命令在`main`函数中运行一次，而反应器则在设置函数完成后，通过回调持续运行。
- 在反应器中，WASI API可能提供额外的参数，指定I/O完成后的继续函数。这样，可以在基于回调的异步环境中使用相同的概念API。

### 为什么没有mmap及其相关函数？
- mmap的支持可能在未来被添加，但它需要与核心语言集成。
- 核心mmap行为在多个方面不具有可移植性，甚至在POSIX风格的系统之间也是如此。而且，mmap的某些特性可能导致用户空间触发信号。
- WASI目前是同步I/O API，但这个设计可能在未来会改变。mmap可能会造成执行加载操作时需要阻塞I/O，这使得难以确定所有可能发生阻塞I/O的地方。

### 为什么没有UNIX域套接字？
- UNIX域套接字可以传递字节、文件描述符和用户凭证。但WASI中没有“用户”的概念，因为许多实现不会以这种方式进行多用户操作。
- 在wasm中，可以通过普通的函数调用来传递文件描述符，这比通过套接字简单快捷得多。

### 为什么没有dup？
- `dup`的主要用例是在执行`fork`之前设置文件描述符。由于WASI没有`fork`，这些用例不适用。

### 为什么`path_remove_directory`和`path_unlink_file`是分开的系统调用？
- 在POSIX中，有一个`unlinkat`函数，通过标志词可以指定是要删除文件还是目录。然而，在WASI中，更倾向于每个系统调用只做一件事，以便清楚地知道导入它的wasm模块可能用它做什么。

文章强调了WebAssembly在设计上的灵活性和前瞻性，以及在构建一个既安全又高效的系统调用接口方面的挑战和机遇。随着WebAssembly的不断发展，这些决策可能会随着社区的反馈和技术的发展而演变。
