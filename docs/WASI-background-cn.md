WebAssembly 的一个最大挑战是弄清楚它的定位。LLVM WebAssembly 后端已经走过许多最终放弃的道路。早期的问题之一是我们应该使用现有的对象文件格式（如 ELF），还是设计一个新格式。

使用现有格式非常有吸引力，因为我们可以使用现有工具，对开发者来说也很熟悉。这甚至可以使某些类型的应用程序移植变得更容易。现有格式还带来了数十年的“经验教训”，这些经验来自许多在各种环境中构建、运行和移植现实世界应用程序的人们。

实际交给平台运行的 WebAssembly 格式是其自己的格式，但有办法使事情工作。为了重用现有的链接器，我们可以有一个后处理工具，将链接器的现有输出格式转换为可运行的 WebAssembly 模块。我们实际上在这方面取得了相当大的进展。

但是，使用 ELF 为例，我们需要创建一个自定义的段类型（在 `PT_LOPROC`-`PT_HIPROC` 范围内）而不是标准 `PT_LOAD` 来加载代码，因为 WebAssembly 函数实际上并没有被加载到程序地址空间中。对于数据的 `PT_LOAD` 也是如此，特别是一旦 WebAssembly 支持线程，内存初始化将需要以不同的方式工作。我们可能会省略 `PT_GNU_STACK`，因为 WebAssembly 的栈不能执行。也许我们可以省略 `PT_PHDR`，因为除非我们在数据中复制段头，否则它们实际上不会在内存中可访问。等等。

虽然理论上一切都可以在名义 ELF 标准内完成，但实际上我们将不得不对现有的 ELF 工具进行重大更改以支持这种使用 ELF 的方式，这将抵消我们希望获得的许多优势。我们仍然会卡在一个自定义的后处理步骤中。而且，由于一切都必须在这个外部约束集内工作，因此更难优化系统以利用 WebAssembly 的独特功能。

因此，尽管 LLVM WebAssembly 后端最初尝试使用 ELF，我们最终决定放弃这一点，设计一个新的格式。

---

现在让我们谈谈 API。

任何看过 Emscripten 在 WebAssembly 和外界之间的接口的人都清楚，当前的系统特别适用于 Emscripten 目前的运作方式，不适合更广泛的采用。随着在浏览器和 JS VM 之外运行 WebAssembly 的兴趣日益增长，这一点尤其正确。

自从 WebAssembly 刚刚开始，就很明显它最终会需要某种“系统调用”类 API，可以标准化，并在任何通用 WebAssembly VM 中实现。

虽然有许多现有系统我们可以模仿，但 [POSIX] 作为一个供应商中立的标准，具有相当的动力。许多人，包括我们，一直在假设 WebAssembly 最终会有某种 POSIX API。一些人甚至已经开始尝试这会是什么样子。

但虽然很多事情映射得相当好，有些事情就不那么清楚了。一个大问题是如何处理“进程”的概念。POSIX 的 IPC 机制是围绕进程设计的，事实上，“IPC”这个术语本身就包含了“进程”。我们对“IPC”意味着什么的理解，包含了对进程是什么以及它们之间的通信是什么样子的理解。

管道、Unix 域套接字、POSIX 共享内存、信号、具有 `fcntl` `F_SETLK`/`F_GETLK` 风格的锁定（与进程相关）的文件，都与进程相关。但是在 WebAssembly 中，什么是进程？

---

假设我们说一个 WebAssembly 实例是“进程”，用于 POSIX API。这最初看起来很有效，但它让我们有几个漏洞需要填补。最重要的是 `fork`。`fork` 是 Unix 的支柱之一，但在完整的 Unix 风格操作系统之外很难实现。我们可能*可以*让它在所有我们想要运行 WebAssembly 的地方工作，但我们真的想这样做吗？它将增加很多复杂性、效率低下、微妙的行为差异，或者现实地说，所有三个的组合。

好吧，也许我们可以鼓励应用程序使用 `posix_spawn` 代替。一些已经这样做了，但这样做我们确实失去了一些 POSIX 的动力。即使有了 `posix_spawn`，许多应用程序也会明确做 `waitpid` 这样的事情。我们也可以让它工作，但我们应该退后一步，思考一下 IPC 总体。

在 WebAssembly 中，实例可以同步调用彼此，这可以非常高效。这不是典型进程可以做到的。可以说，我们现在认为的很多“IPC”只是在弥补进程之间无法相互调用的不足。而且，WebAssembly 实例将能够导入彼此的内存和表格，最终甚至可以传递它们内存的切片。在 WebAssembly 圈子中，我们甚至不倾向于将这些视为 IPC 机制，因为进程隐喻在这里并不适合。我们希望应用程序使用这些机制，因为它们高效且充分利用了平台，而不是使用传统的 Unix 风格 IPC，后者通常涉及仿真和效率低下。

当然，帮助现有应用程序移植总是有一席之地的。模拟各种 Unix 语义的库是有价值的。但我们可以把它们视为解决某些实际问题的工具，而不是系统的主接口，因为它们错过了平台的一些基本功能。

---

`mmap` 的一些基本假设是存在一个相对较大的虚拟地址空间，以及未映射的页面不占用实际内存。前者在 WebAssembly 中往往不成立，其中线性地址空间往往只有必要那么大。

对于后者，是否有可能使 WebAssembly 引擎能够取消映射线性内存区域中间的页面，并释放资源？当然可以。这是我们希望 WebAssembly 程序通常做的编程技术，要求所有 VM 实现这一点吗？可能不是。

正在出现的是一种感觉，我们想要的是一套核心 API，可以非常广泛地实现，然后是可选的 API 模块，VM 可以根据自己的需要选择支持。

有了这种心态，`mmap` 感觉像是属于这些可选集之一，而不是核心。

（尽管请注意，即使对于快速读取文件的用例，`mmap` [并不总是比直接读入缓冲区更好](https://blog.burntsushi.net/ripgrep/)。

---

一个 WebAssembly 移植的 Debian 怎么样？

这是一个思想实验。Debian 被移植到许多硬件架构上。在某些设置中，WebAssembly 被视为硬件架构。将 Debian 用户空间移植到 WebAssembly 有没有意义？这会是什么样子？它会有什么用？

在浏览器中运行一个由 WebAssembly 驱动的 Unix  shell 环境甚至图形桌面环境会有点酷。但这真的会很酷吗？比 SSH 或 VNC 会话到云实例更酷吗？因为要做很多事情，你会想要一个文件系统、一个网络栈等等，而浏览器只会让你做这么多。

可以肯定的是，这肯定会很酷。但在某些圈子中，有一种倾向是将像 Debian 这样的系统视为 WebAssembly 系统 API 和工具链的自然终极目标。我们自己也有这样的倾向。但它从未真正清楚该如何运作。

这里的洞见是，我们可以分割设计空间，而不是试图一次性解决所有问题。我们可以有一套核心 API，对大多数应用程序来说已经足够，但并不试图支持所有 Debian 用户空间。这将使实现更加可移植、灵活、可测试和健壮，而不是如果我们试图让每个实现都支持一切，或者提出自定义子集。

如上所述，除了核心 WASI 集之外，还有空间添加额外的可选 API。绝对有地方用于功能不在标准平台中的工具和库。因此，对 Debian 移植感兴趣的人仍然可以向前迈进，但我们不需要让这一点成为核心 WASI 设计的重点。

---

一个画面出现了

虽然这里写的很多东西在事后看来似乎是相对明显的，但这种清晰度是相对较新的。我们现在看到许多一直在旋转的想法，有些想法和 WebAssembly 本身一样古老，汇集成一个连贯的总体计划，这使得这是一个令人兴奋的时刻。

